#include <cstring> // strchr 
#include "BufferedLine.h"
#include "CpptrajStdio.h"

BufferedLine::BufferedLine() :
  buffer_(0),
  bufferPosition_(0),
  tokenidx_(0),
  saveChar_(0),
  lineEnd_(0),
  endChar_(0),
  endBuffer_(0),
  nline_(0)
{}

BufferedLine::~BufferedLine() {
  if (buffer_!=0) delete[] buffer_;
}

// BufferedLine::ResetBuffer()
int BufferedLine::ResetBuffer() {
  if (buffer_!=0) delete[] buffer_;
  buffer_ = new char[ DEFAULT_BUFFERSIZE + 1];
  buffer_[ DEFAULT_BUFFERSIZE ] = '\0';
  bufferPosition_ = buffer_;
  endBuffer_ = bufferPosition_; // This guarantees on first BufferedLine buffer will be filled
  lineEnd_= bufferPosition_;
  nline_ = 0;
  return 0;
} 

// BufferedLine::Line()
const char* BufferedLine::Line() {
  *lineEnd_ = endChar_;
  bufferPosition_ = lineEnd_;
  // Search for next end line 
  lineEnd_ = bufferPosition_;
  while (lineEnd_ <= endBuffer_) {
    // Fill buffer if needed
    if (lineEnd_ == endBuffer_) {
      size_t bufferRemainder = endBuffer_ - bufferPosition_;
      if (bufferRemainder == DEFAULT_BUFFERSIZE) break;
      memcpy(buffer_, bufferPosition_, bufferRemainder);
      int Nread = Read(buffer_ + bufferRemainder, DEFAULT_BUFFERSIZE - bufferRemainder);
      if (Nread < 1) return 0;
      bufferPosition_ = buffer_;
      lineEnd_ = buffer_ + bufferRemainder;
      endBuffer_ = lineEnd_ + (size_t)Nread;
      // TODO: Check if this has happened multiple times with no endline
    }
    if ( *(lineEnd_++) == '\n') {
      // End of the line
      endChar_ = *lineEnd_;
      *lineEnd_ = '\0';
      ++nline_;
      return bufferPosition_;
    }
  }
  // Should never get here. Could implement a realloc above.
  mprinterr("Internal Error: Input line size > internal buffer size (%lu)\n", 
            DEFAULT_BUFFERSIZE);
  mprinterr("Internal Error: Increase the size of BufferedLine::DEFAULT_BUFFERSIZE and recompile\n");
  return 0;
}

/** Separate the current line into tokens delimited by given chars. 
  * \return Number of tokens.
  */
int BufferedLine::TokenizeLine(const char* separator) {
  if ( separator == 0 ) return 0;
  char* linechar = bufferPosition_;
  bool inToken = false;
  tokens_.clear();
  // NOTE: Just check for newline?
  while ( *linechar != '\0' && *linechar != '\n' ) {
    if (!inToken) { // Not in token.
      if ( strchr( separator, *linechar ) == 0 ) {
        tokens_.push_back( linechar); // Pointer to beginning of token.
        inToken = true;
      }
    } else {        // In a token.
      if ( strchr( separator, *linechar ) != 0 ) {
        tokens_.push_back( linechar ); // Pointer to end of token.
        inToken = false;
      }
    }
    ++linechar;
  }
  // If inToken is still true point to linechar as the last token
  if (inToken)
    tokens_.push_back(linechar);
  tokenidx_ = 0; 
  /*mprintf("DBG: Tokenize: Line=[%s]\n", bufferPosition_);
  mprintf("\t%i Tokens:\n", ntokens);
  for (unsigned int t = 0; t < ntokens; ++t)
    mprintf("\t\t%u %c\n",t, *tokens_[t]);*/
  return (int)(tokens_.size() / 2);
}

/** Following a call to TokenizeLine return char* to next token in the
  * line. Token is generated by inserting a null char at the current
  * token end position; this char is restored once NextToken is called
  * again.
  */
const char* BufferedLine::NextToken() {
  if (tokenidx_ == tokens_.size()) return 0;
  char* tokenptr = tokens_[tokenidx_];
  if (tokenidx_ != 0)
    *(tokens_[tokenidx_-1]) = saveChar_;
  char* nextptr = tokens_[tokenidx_+1];
  saveChar_ = *nextptr;
  *nextptr = '\0';
  tokenidx_ += 2;
  return tokenptr;
}
